## 1. 氣泡排序法 Bubble Sort
氣泡排序法是最直覺可以想到的排序方法，主要就是將兩元素拿來做比較，先用一個 index 從頭開始掃，再用另外一個 index 與相鄰元素比較，此種作法在升序排列中，第一步會將最大值擺到最後，所以共需要 1+2+3+...+(n-1) = n(n-1)/2 步，時間複雜度為 O(n<sup>2</sup>)。其過程像是泡泡依樣從下面跑上來，故稱氣泡排序法。而在算法中僅需要多一個變數即可完成，故空間複雜度為 O(1)。若兩元素相等，則不執行交換，故為穩定的算法。也可看到 bubbleSort 的程式碼非常短，故在欲排序的資料非常少時可以考慮使用。
```C
void bubbleSort(int a[], int length)
{
    int i, j, temp;
    for(i = 0; i < length; i++)
    {
        for(j = 0; j < length - 1 - i; j++)
        {
            if(a[j] > a[j+1])
            {
                temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
            }
        }
    }
}
9  7  4  5  8  6  //一開始
7  4  5  8  6  9  
4  5  7  6  8  9  
4  5  6  7  8  9  
4  5  6  7  8  9  
4  5  6  7  8  9  
4  5  6  7  8  9  
4  5  6  7  8  9
```

## 2. 插入排序法 Insertion Sort
在撲克牌理牌的時候會將第 i 張牌與 0 ~ i-1 張牌作比較，當該張牌小於裡面的某個值，就把該張牌插入該位置，並將排由後往前交換使得值能夠依序排列，此即為插入排序法的想法。而此種排序法共需要 1+2+3+...+(n-1) = n(n-1)/2，時間複雜度為 O(n<sup>2</sup>)。而在算法中僅需要多一個變數即可完成，故空間複雜度為 O(1)。若兩元素相等，則不執行交換，故為穩定的算法。
```C
void insertionSort(int a[], int n)
{
    int i, j, temp;
    for(i = 1; i < n; i++)
    {
        temp = a[i];
        j = i-1;
        while(j >= 0 && a[j] > temp)
        {
            a[j+1] = a[j];
            j--;
        }
        a[j+1] = temp;
    }
}
```
## 3. 選擇排序法 Selection Sort
假設為升序排列且有 n 個元素，先將所有元素中最小值找出來放到首位，接著找第 1~n 個元素中的最小值放到次位，以此類推，此即為選擇排序法。此種方法需要 n+(n-1)+(n-2)...+1 = n(n+1)/2，時間複雜度為 O(n<sup>2</sup>)。而在算法中僅需要多二個變數即可完成，故空間複雜度為 O(1)。若兩元素相等，則不執行交換，故為穩定的算法。
```C
void selection_sort(int a[], int len) 
{
    int i,j,temp;

	for (i = 0 ; i < len - 1 ; i++) 
    {
        int min = i;
		for (j = i + 1; j < len; j++) if (a[j] < a[min])  min = j;  //走訪未排序的元素，找到並紀錄最小值
		if(min != i)
		{
            temp=a[min];  //交換兩個變數
            a[min]=a[i];
            a[i]=temp;
		}
	}
}
```
## 4. 
